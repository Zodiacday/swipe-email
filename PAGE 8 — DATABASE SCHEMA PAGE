8. DATABASE SCHEMA
This page defines the entire database layer for the product.
It includes:

Tables

Fields

Types

Indexing strategy

Relationships

Constraints

Safety rules

Migration philosophy

The schema is designed for:

High read/write throughput

Fast swipe actions

Fast email lookups

Efficient sender/domain queries

AI training signals

Undo support

Multi‑provider support

The database is relational (PostgreSQL recommended), with selective use of JSONB for flexible metadata.

8.1 Core Tables Overview
The system uses the following primary tables:

users

email_accounts

emails

senders

domains

actions

rules

ai_signals

cleanup_logs

undo_tokens

Each table is detailed below.

8.2 Table: users
Stores user identity and global settings.

Schema
Code
users {
  id                UUID (PK)
  created_at        TIMESTAMP
  updated_at        TIMESTAMP
  name              TEXT
  email             TEXT UNIQUE
  onboarding_state  TEXT
  settings          JSONB
}
Indexes
email (unique)

Notes
settings stores UI preferences, AI preferences, etc.

8.3 Table: email_accounts
Represents each connected inbox.

Schema
Code
email_accounts {
  id                UUID (PK)
  user_id           UUID (FK → users.id)
  provider          TEXT  -- gmail, outlook, yahoo, icloud, imap
  email_address     TEXT
  access_token      TEXT (encrypted)
  refresh_token     TEXT (encrypted)
  token_expires_at  TIMESTAMP
  sync_cursor       TEXT
  created_at        TIMESTAMP
  updated_at        TIMESTAMP
}
Indexes
user_id

email_address

Notes
sync_cursor stores provider‑specific pagination tokens.

8.4 Table: emails
Stores normalized email metadata.

Schema
Code
emails {
  id                UUID (PK)
  account_id        UUID (FK → email_accounts.id)
  provider_id       TEXT  -- provider-specific message ID
  sender_id         UUID (FK → senders.id)
  domain_id         UUID (FK → domains.id)
  subject           TEXT
  timestamp         TIMESTAMP
  category          TEXT  -- newsletter, promo, social, transactional, personal, unknown
  list_unsubscribe  JSONB  -- { http: string | null, mailto: string | null }
  metadata          JSONB  -- provider-specific metadata
  is_deleted        BOOLEAN DEFAULT false
  created_at        TIMESTAMP
}
Indexes
(account_id, provider_id) unique

sender_id

domain_id

timestamp

category

Notes
No email content is stored.

Only metadata.

8.5 Table: senders
Represents unique email senders.

Schema
Code
senders {
  id                UUID (PK)
  email_address     TEXT UNIQUE
  domain_id         UUID (FK → domains.id)
  reputation_score  FLOAT  -- 0 to 1
  frequency_score   FLOAT
  last_seen         TIMESTAMP
  created_at        TIMESTAMP
}
Indexes
email_address (unique)

domain_id

Notes
reputation_score is updated by AI Janitor.

frequency_score is derived from email volume.

8.6 Table: domains
Represents unique domains.

Schema
Code
domains {
  id                UUID (PK)
  domain_name       TEXT UNIQUE
  reputation_score  FLOAT
  is_safe_to_nuke   BOOLEAN
  created_at        TIMESTAMP
}
Indexes
domain_name (unique)

Notes
is_safe_to_nuke is determined by safety rules.

8.7 Table: actions
Logs every user action (delete, unsubscribe, block, keep, nuke).

Schema
Code
actions {
  id                UUID (PK)
  user_id           UUID (FK → users.id)
  email_id          UUID (FK → emails.id)
  action_type       TEXT  -- delete, unsubscribe, block, keep, nuke
  provider          TEXT
  timestamp         TIMESTAMP
  metadata          JSONB
}
Indexes
user_id

email_id

action_type

timestamp

Notes
Powers undo, stats, AI learning.

8.8 Table: rules
Stores automation rules created by the user or suggested by AI.

Schema
Code
rules {
  id                UUID (PK)
  user_id           UUID (FK → users.id)
  rule_type         TEXT  -- auto_delete, auto_block, auto_nuke, auto_archive
  sender_id         UUID (FK → senders.id) NULL
  domain_id         UUID (FK → domains.id) NULL
  conditions        JSONB
  created_at        TIMESTAMP
  updated_at        TIMESTAMP
  is_enabled        BOOLEAN DEFAULT true
}
Indexes
user_id

sender_id

domain_id

Notes
Rules must be reversible.

8.9 Table: ai_signals
Stores AI Janitor outputs for training and insights.

Schema
Code
ai_signals {
  id                UUID (PK)
  email_id          UUID (FK → emails.id)
  sender_id         UUID (FK → senders.id)
  domain_id         UUID (FK → domains.id)
  suggested_action  TEXT
  confidence        FLOAT
  spam_score        FLOAT
  sender_score      FLOAT
  cluster           TEXT
  timestamp         TIMESTAMP
}
Indexes
email_id

sender_id

domain_id

Notes
Used for analytics and model improvement.

8.10 Table: cleanup_logs
Tracks cleanup sessions.

Schema
Code
cleanup_logs {
  id                UUID (PK)
  user_id           UUID (FK → users.id)
  session_id        UUID
  emails_processed  INT
  actions_taken     INT
  time_spent_ms     INT
  timestamp         TIMESTAMP
}
Indexes
user_id

session_id

Notes
Powers streaks, stats, insights.

8.11 Table: undo_tokens
Stores undoable actions.

Schema
Code
undo_tokens {
  id                UUID (PK)
  user_id           UUID (FK → users.id)
  action_id         UUID (FK → actions.id)
  expires_at        TIMESTAMP
  metadata          JSONB
}
Indexes
user_id

action_id

expires_at

Notes
Undo window: 30 seconds minimum.

8.12 Relationships Diagram (Text Version)
Code
users
  └── email_accounts
        └── emails
              ├── senders
              └── domains

users
  └── actions
        └── emails
              ├── senders
              └── domains

users
  └── rules
        ├── senders
        └── domains

emails
  └── ai_signals

users
  └── cleanup_logs

users
  └── undo_tokens
8.13 Indexing Strategy
High‑priority indexes
emails (account_id, timestamp)

emails (sender_id)

emails (domain_id)

senders (email_address)

domains (domain_name)

actions (user_id, timestamp)

Why?
Fast swipe queue

Fast sender lookups

Fast domain nukes

Fast AI training

8.14 Constraints & Safety
1. No email content stored
Metadata only.

2. No irreversible deletes
Use soft deletes.

3. All rules must be reversible
Undo tokens required.

4. Provider IDs must be unique per account
Prevents duplicates.

5. Domain nukes must check safety flag
is_safe_to_nuke = true

8.15 Migration Philosophy
Always additive

Never destructive

Use versioned migrations

Zero downtime

Backward compatible
